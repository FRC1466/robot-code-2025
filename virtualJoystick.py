import tkinter as tk
import pyvjoy
import math


# Virtual Joystick, to enable robot driving even without the physical joystick
# This code is based on the Virtual Thrustmaster T.16000M FCS Controller
# Generated by ChatGPT, check for errors

# vJoy axes values typically range from 0 to 32767.
AXIS_MAX = 32767

class VirtualThrustmaster:
    def __init__(self, root):
        # Initialize vJoy device (using device ID 1)
        self.joystick = pyvjoy.VJoyDevice(1)
        self.ui_scale = 1.0  # Add UI scale factor
        self.clear_states()

        # Remove scale slider and keep other UI sections
        self.create_x_slider(root)
        self.create_y_slider(root)
        self.create_buttons_frame(root)
        self.create_hat_switch_frame(root)

        # Add keyboard bindings for scaling
        root.bind('<Control-plus>', self.increase_scale)
        root.bind('<Control-minus>', self.decrease_scale)
        root.bind('<Control-equal>', self.increase_scale)  # For keyboards where + is on =

    def increase_scale(self, event):
        self.ui_scale = min(2.0, self.ui_scale + 0.1)
        self.apply_scale()

    def decrease_scale(self, event):
        self.ui_scale = max(0.5, self.ui_scale - 0.1)
        self.apply_scale()

    def apply_scale(self):
        # Scale all the UI elements
        scaled_length = int(300 * self.ui_scale)
        self.x_slider.config(length=scaled_length)
        self.y_slider.config(length=scaled_length)
        
        # Scale button sizes
        button_width = int(10 * self.ui_scale)
        for btn in self.button_widgets.values():
            btn.config(width=button_width)
        
        for btn in self.hat_buttons.values():
            btn.config(width=button_width)
        
        # Scale hat visualization
        new_size = int(150 * self.ui_scale)
        self.hat_canvas.config(width=new_size, height=new_size)
        self.hat_canvas_size = new_size
        self.update_hat_visualization(self.current_hat)

    def clear_states(self):
        # Center main stick axes and clear button states.
        center_value = AXIS_MAX // 2
        self.joystick.set_axis(pyvjoy.HID_USAGE_X, center_value)
        self.joystick.set_axis(pyvjoy.HID_USAGE_Y, center_value)
        self.joystick.set_axis(pyvjoy.HID_USAGE_Z, center_value)  # Initialize twist axis (Z) to center
        self.joystick.set_cont_pov(1, -1)  # POV neutral
        self.button_states = {}
        for btn in range(1, 17):
            self.button_states[btn] = False
            self.joystick.set_button(btn, 0)
        # Current hat position: default to neutral (grid cell (1,1))
        self.current_hat = (1, 1)

    def create_x_slider(self, root):
        # X axis slider with a continuous range and auto-reset on release.
        self.x_frame = tk.LabelFrame(root, text="X Axis")
        self.x_frame.pack(padx=10, pady=10)
        self.x_slider = tk.Scale(self.x_frame, from_=0, to=AXIS_MAX, resolution=1,
                                 orient=tk.HORIZONTAL, length=300,
                                 command=self.on_x_change)
        self.x_slider.set(AXIS_MAX // 2)
        self.x_slider.pack()
        self.x_slider.bind("<ButtonRelease-1>", self.on_x_release)

    def on_x_change(self, value):
        x_val = int(float(value))
        # Apply scaling relative to center
        center = AXIS_MAX // 2
        offset = x_val - center
        scaled_offset = int(offset * self.ui_scale)
        scaled_value = center + scaled_offset
        # Ensure value stays within valid range
        scaled_value = max(0, min(AXIS_MAX, scaled_value))
        self.joystick.set_axis(pyvjoy.HID_USAGE_X, scaled_value)

    def on_x_release(self, event):
        # Reset slider to center
        self.x_slider.set(AXIS_MAX // 2)
        self.joystick.set_axis(pyvjoy.HID_USAGE_X, AXIS_MAX // 2)

    def create_y_slider(self, root):
        # Y axis slider with a continuous range and auto-reset on release.
        self.y_frame = tk.LabelFrame(root, text="Y Axis")
        self.y_frame.pack(padx=10, pady=10)
        self.y_slider = tk.Scale(self.y_frame, from_=0, to=AXIS_MAX, resolution=1,
                                 orient=tk.VERTICAL, length=300,
                                 command=self.on_y_change)
        self.y_slider.set(AXIS_MAX // 2)
        self.y_slider.pack()
        self.y_slider.bind("<ButtonRelease-1>", self.on_y_release)

    def on_y_change(self, value):
        y_val = int(float(value))
        # Apply scaling relative to center
        center = AXIS_MAX // 2
        offset = y_val - center
        scaled_offset = int(offset * self.ui_scale)
        scaled_value = center + scaled_offset
        # Ensure value stays within valid range
        scaled_value = max(0, min(AXIS_MAX, scaled_value))
        self.joystick.set_axis(pyvjoy.HID_USAGE_Y, scaled_value)

    def on_y_release(self, event):
        # Reset slider to center
        self.y_slider.set(AXIS_MAX // 2)
        self.joystick.set_axis(pyvjoy.HID_USAGE_Y, AXIS_MAX // 2)

    def create_buttons_frame(self, root):
        # 16 Flightstick buttons with visual toggle feedback.
        self.buttons_frame = tk.LabelFrame(root, text="Flightstick Buttons")
        self.buttons_frame.pack(padx=10, pady=10)
        self.button_widgets = {}
        for i in range(16):
            btn_num = i + 1
            btn = tk.Button(self.buttons_frame, text=f"{btn_num}", width=10,
                            command=lambda b=btn_num: self.toggle_button(b))
            btn.grid(row=i // 4, column=i % 4, padx=5, pady=5)
            self.button_widgets[btn_num] = btn

    def toggle_button(self, btn_num):
        # Toggle button state and change its background color.
        self.button_states[btn_num] = not self.button_states[btn_num]
        self.joystick.set_button(btn_num, int(self.button_states[btn_num]))
        if self.button_states[btn_num]:
            self.button_widgets[btn_num].config(bg="green")
        else:
            self.button_widgets[btn_num].config(bg="SystemButtonFace")

    def create_hat_switch_frame(self, root):
        # Create a 3x3 grid for the hat switch buttons.
        self.hat_frame = tk.LabelFrame(root, text="Hat Switch")
        self.hat_frame.pack(padx=10, pady=10)
        # The keys (row, col) correspond to grid positions.
        self.hat_mapping = {
            (0, 0): ("Up-Left", 31500),
            (0, 1): ("Up", 0),
            (0, 2): ("Up-Right", 4500),
            (1, 0): ("Left", 27000),
            (1, 1): ("Neutral", -1),
            (1, 2): ("Right", 9000),
            (2, 0): ("Down-Left", 22500),
            (2, 1): ("Down", 18000),
            (2, 2): ("Down-Right", 13500)
        }
        self.hat_buttons = {}
        for pos, (label, angle) in self.hat_mapping.items():
            btn = tk.Button(self.hat_frame, text=label, width=10,
                            command=lambda a=angle, p=pos: self.set_hat(a, p))
            btn.grid(row=pos[0], column=pos[1], padx=2, pady=2)
            self.hat_buttons[pos] = btn

        # Hat switch visualization canvas:
        self.hat_canvas_size = 150
        self.hat_canvas = tk.Canvas(self.hat_frame, width=self.hat_canvas_size, height=self.hat_canvas_size, bg="white")
        self.hat_canvas.grid(row=3, column=0, columnspan=3, pady=5)
        self.update_hat_visualization((1, 1))  # Start at neutral

    def set_hat(self, angle, pos):
        # Set the POV hat value and update visual feedback.
        self.joystick.set_cont_pov(1, angle)
        self.current_hat = pos
        # Highlight the pressed hat button; reset others.
        for p, btn in self.hat_buttons.items():
            btn.config(bg="green" if p == pos else "SystemButtonFace")
        self.update_hat_visualization(pos)

    def update_hat_visualization(self, pos):
        # Clear previous visualization.
        self.hat_canvas.delete("arrow")
        center = self.hat_canvas_size / 2
        cell_size = self.hat_canvas_size / 3

        # Calculate the center of the grid cell corresponding to the pressed hat button.
        target_x = pos[1] * cell_size + cell_size / 2
        target_y = pos[0] * cell_size + cell_size / 2

        # If neutral (center cell) then just draw a dot.
        if pos == (1, 1):
            self.hat_canvas.create_oval(center - 5, center - 5, center + 5, center + 5,
                                          fill="black", tags="arrow")
        else:
            # Draw an arrow from the neutral center to the target cell center.
            self.hat_canvas.create_line(center, center, target_x, target_y,
                                          arrow=tk.LAST, fill="red", width=3, tags="arrow")

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Virtual Thrustmaster T.16000M FCS Emulator")
    app = VirtualThrustmaster(root)
    root.mainloop()
